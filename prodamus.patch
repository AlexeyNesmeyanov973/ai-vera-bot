diff --git a/.env.example b/.env.example
index 1111111..2222222 100644
--- a/.env.example
+++ b/.env.example
@@ -1,13 +1,22 @@
-# –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
-TELEGRAM_BOT_TOKEN=your_telegram_bot_token_here
-ADMIN_USER_IDS=123456789
-
-# Paydmus –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
-PAYDUS_WEBHOOK_SECRET=your_paydmus_webhook_secret
-PAYDUS_PRO_AMOUNT=299.0
-
-# –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
-PRO_USER_IDS=987654321
-WHISPER_MODEL=base
+# –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
+TELEGRAM_BOT_TOKEN=your_telegram_bot_token_here
+ADMIN_USER_IDS=123456789
+
+# Prodamus
+PRODAMUS_WEBHOOK_SECRET=your_prodamus_webhook_secret
+# –ì–æ—Ç–æ–≤–∞—è –ø–ª–∞—Ç—ë–∂–Ω–∞—è —Å—Å—ã–ª–∫–∞ –∏–∑ –∫–∞–±–∏–Ω–µ—Ç–∞ Prodamus (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ –æ–ø–ª–∞—Ç—ã).
+# –ú–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å –±–µ–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ ‚Äî –±–æ—Ç –¥–æ–±–∞–≤–∏—Ç ?user_id=...&amount=...
+PRODAMUS_PAYMENT_LINK=https://payform.prodamus.ru/your-page
+PRODAMUS_PRO_AMOUNT=299.0
+
+# –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ
+WHISPER_BACKEND=faster   # "openai" –∏–ª–∏ "faster"
+WHISPER_MODEL=small      # openai: base/small/...; faster: small/medium/large-v3 –∏ —Ç.–ø.
+
+# –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
+PRO_USER_IDS=987654321
+
+# –•—Ä–∞–Ω–∏–ª–∏—â–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
+# REDIS_URL=redis://default:password@host:6379/0
+# DATABASE_URL=postgresql://user:password@host:5432/dbname
diff --git a/render.yaml b/render.yaml
index 3333333..4444444 100644
--- a/render.yaml
+++ b/render.yaml
@@ -1,44 +1,56 @@
 services:
   - type: worker
     name: ai-vera-bot-worker
     runtime: docker
     dockerfilePath: Dockerfile
-    dockerCommand: python -m app.bot
+    dockerCommand: python -m app.bot
     envVars:
-      - key: PRO_USER_IDS
-        sync: false
       - key: TELEGRAM_BOT_TOKEN
         sync: false
       - key: ADMIN_USER_IDS
         sync: false
-      - key: PRO_USER_IDS
-        sync: false
-      - key: PAYDUS_WEBHOOK_SECRET
+      - key: PRO_USER_IDS
         sync: false
-      - key: PAYDUS_PRO_AMOUNT
-        value: "299.0"
-        - key: WHISPER_BACKEND       # "openai" –∏–ª–∏ "faster"
-        value: "faster"
-      - key: WHISPER_MODEL         # –¥–ª—è openai: base/small/...; –¥–ª—è faster: small/medium/large-v3 –∏ —Ç.–ø.
-        value: "small"
+      - key: PRODAMUS_WEBHOOK_SECRET
+        sync: false
+      - key: PRODAMUS_PAYMENT_LINK
+        sync: false
+      - key: PRODAMUS_PRO_AMOUNT
+        value: "299.0"
+      - key: WHISPER_BACKEND         # "openai" –∏–ª–∏ "faster"
+        value: "faster"
+      - key: WHISPER_MODEL           # openai: base/small/...; faster: small/medium/large-v3
+        value: "small"
       - key: REDIS_URL             # –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
         sync: false
       - key: DATABASE_URL          # –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ (postgres://... –∏–ª–∏ postgresql://...)
         sync: false
 
   - type: web
     name: ai-vera-bot-web
     runtime: docker
     dockerfilePath: Dockerfile
-    dockerCommand: python -m app.web
+    dockerCommand: gunicorn -w 2 -k gthread -b 0.0.0.0:$PORT app.web:app
     envVars:
       - key: TELEGRAM_BOT_TOKEN
         sync: false
       - key: ADMIN_USER_IDS
         sync: false
       - key: PRO_USER_IDS
         sync: false
-      - key: PAYDUS_WEBHOOK_SECRET
+      - key: PRODAMUS_WEBHOOK_SECRET
         sync: false
-      - key: PAYDUS_PRO_AMOUNT
-        value: "299.0"
+      - key: PRODAMUS_PAYMENT_LINK
+        sync: false
+      - key: PRODAMUS_PRO_AMOUNT
+        value: "299.0"
+      - key: WHISPER_BACKEND
+        value: "faster"
+      - key: WHISPER_MODEL
+        value: "small"
+      - key: REDIS_URL
+        sync: false
+      - key: DATABASE_URL
+        sync: false
diff --git a/app/config.py b/app/config.py
index 5555555..6666666 100644
--- a/app/config.py
+++ b/app/config.py
@@ -1,33 +1,43 @@
 import os
 from dotenv import load_dotenv
 from app.payment_manager import PaymentManager
 
 load_dotenv()
 
 TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
 if not TELEGRAM_BOT_TOKEN:
     raise ValueError("–û–®–ò–ë–ö–ê: –ù–µ –Ω–∞–π–¥–µ–Ω TELEGRAM_BOT_TOKEN –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è.")
 
 FREE_USER_DAILY_LIMIT_MINUTES = 30
 PRO_USER_DAILY_LIMIT_MINUTES = 120
 MAX_FILE_SIZE_MB = 20
 
 ADMIN_USER_IDS = list(map(int, os.getenv('ADMIN_USER_IDS', '').split(','))) if os.getenv('ADMIN_USER_IDS') else []
 PRO_USER_IDS = list(map(int, os.getenv('PRO_USER_IDS', '').split(','))) if os.getenv('PRO_USER_IDS') else []
 
 # –ë—ç–∫–µ–Ω–¥ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è: "openai" | "faster"
 WHISPER_BACKEND = os.getenv('WHISPER_BACKEND', 'faster').lower()
 WHISPER_MODEL = os.getenv('WHISPER_MODEL', 'small')
 
-# Paydmus
-PAYDMUS_WEBHOOK_SECRET = os.getenv('PAYDMUS_WEBHOOK_SECRET', '')
-PAYDMUS_PRO_AMOUNT = float(os.getenv('PAYDMUS_PRO_AMOUNT', '299.0'))
+# Prodamus
+PRODAMUS_WEBHOOK_SECRET = os.getenv('PRODAMUS_WEBHOOK_SECRET', '')
+PRODAMUS_PRO_AMOUNT = float(os.getenv('PRODAMUS_PRO_AMOUNT', '299.0'))
+PRODAMUS_PAYMENT_LINK = os.getenv('PRODAMUS_PAYMENT_LINK', '').strip()
 
 # –•—Ä–∞–Ω–∏–ª–∏—â–∞
 REDIS_URL = os.getenv('REDIS_URL', '')
 DATABASE_URL = os.getenv('DATABASE_URL', '')
 
 payment_manager = None
-if PAYDMUS_WEBHOOK_SECRET:
-    payment_manager = PaymentManager(PAYDMUS_WEBHOOK_SECRET)
+if PRODAMUS_WEBHOOK_SECRET:
+    payment_manager = PaymentManager(
+        webhook_secret=PRODAMUS_WEBHOOK_SECRET,
+        payment_link_base=PRODAMUS_PAYMENT_LINK or None,
+        default_amount=PRODAMUS_PRO_AMOUNT
+    )
 else:
-    print("‚ö†Ô∏è  PAYDMUS_WEBHOOK_SECRET –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ü–ª–∞—Ç–µ–∂–∏ –æ—Ç–∫–ª—é—á–µ–Ω—ã.")
+    print("‚ö†Ô∏è  PRODAMUS_WEBHOOK_SECRET –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ü–ª–∞—Ç–µ–∂–∏ –æ—Ç–∫–ª—é—á–µ–Ω—ã.")
diff --git a/app/payment_manager.py b/app/payment_manager.py
index 7777777..8888888 100644
--- a/app/payment_manager.py
+++ b/app/payment_manager.py
@@ -1,53 +1,168 @@
-import logging
-import hmac
-import hashlib
-from typing import Dict
-from app import storage
-
-logger = logging.getLogger(__name__)
-
-class PaymentManager:
-    """Paydmus."""
-    def __init__(self, webhook_secret: str):
-        self.webhook_secret = webhook_secret.encode('utf-8')
-
-    def verify_webhook_signature(self, payload: bytes, signature: str) -> bool:
-        try:
-            expected = hmac.new(self.webhook_secret, payload, hashlib.sha256).hexdigest()
-            return hmac.compare_digest(expected, signature)
-        except Exception as e:
-            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∏: {e}")
-            return False
-
-    async def handle_webhook(self, payload: Dict) -> Dict:
-        try:
-            event = payload.get('event')
-            order = payload.get('order', {})
-            user_id = order.get('user_id')
-            if not user_id:
-                return {'success': False, 'error': 'No user_id'}
-
-            user_id = int(user_id)
-
-            if event == 'order.paid':
-                storage.add_pro(user_id)
-                logger.info(f"User {user_id} upgraded to PRO")
-                return {'success': True, 'message': f'User {user_id} upgraded to PRO'}
-
-            elif event == 'order.refunded':
-                storage.remove_pro(user_id)
-                logger.info(f"User {user_id} downgraded from PRO")
-                return {'success': True, 'message': f'User {user_id} downgraded from PRO'}
-
-            return {'success': False, 'error': 'Unknown event type'}
-        except Exception as e:
-            logger.error(f"Webhook error: {e}")
-            return {'success': False, 'error': str(e)}
-
-    def get_payment_url(self, user_id: int, amount: float = 299.0) -> str:
-        base_url = "https://paydmus.com/api/v1/payment"
-        return f"{base_url}?user_id={user_id}&amount={amount}&product_name=AI+Vera+PRO"
+import logging
+import hmac
+import hashlib
+import json
+from typing import Dict, Optional
+from urllib.parse import urlencode, urlparse, parse_qsl, urlunparse
+
+from app import storage
+
+logger = logging.getLogger(__name__)
+
+class PaymentManager:
+    """
+    –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Prodamus:
+    - –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∏ –≤–µ–±—Ö—É–∫–∞: HMAC-SHA256(raw_body, secret) == signature_header
+    - –°—Å—ã–ª–∫–∞ –Ω–∞ –æ–ø–ª–∞—Ç—É: –∏—Å–ø–æ–ª—å–∑—É–µ–º –≥–æ—Ç–æ–≤—É—é —Å—Å—ã–ª–∫—É –∏–∑ –∫–∞–±–∏–Ω–µ—Ç–∞ –∏ –¥–æ–±–∞–≤–ª—è–µ–º ?user_id=...&amount=...
+    """
+
+    SIGNATURE_HEADER_CANDIDATES = [
+        "X-Prodamus-Signature",
+        "X-Signature",
+        "Signature",
+        "X-Pay-Signature",
+    ]
+
+    def __init__(self, webhook_secret: str, payment_link_base: Optional[str], default_amount: float = 299.0):
+        self.webhook_secret = webhook_secret.encode("utf-8")
+        self.payment_link_base = payment_link_base
+        self.default_amount = default_amount
+
+    def _extract_signature(self, headers: Dict[str, str]) -> Optional[str]:
+        for key in self.SIGNATURE_HEADER_CANDIDATES:
+            if key in headers:
+                return headers.get(key)
+            for hk, hv in headers.items():
+                if hk.lower() == key.lower():
+                    return hv
+        return None
+
+    def verify_webhook_signature(self, raw_payload: bytes, headers: Dict[str, str]) -> bool:
+        try:
+            signature = self._extract_signature(headers)
+            if not signature:
+                logger.warning("–ü–æ–¥–ø–∏—Å—å –≤–µ–±—Ö—É–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ –∑–∞–≥–æ–ª–æ–≤–∫–∞—Ö")
+                return False
+            expected = hmac.new(self.webhook_secret, raw_payload, hashlib.sha256).hexdigest()
+            return hmac.compare_digest(expected, signature)
+        except Exception as e:
+            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∏: {e}")
+            return False
+
+    def _extract_user_id(self, payload: Dict) -> Optional[int]:
+        candidates = [
+            payload.get("user_id"),
+            (payload.get("order") or {}).get("user_id"),
+            ((payload.get("custom_fields") or {}).get("user_id") if isinstance(payload.get("custom_fields"), dict) else None),
+            ((payload.get("params") or {}).get("user_id") if isinstance(payload.get("params"), dict) else None),
+            ((payload.get("client") or {}).get("user_id") if isinstance(payload.get("client"), dict) else None),
+        ]
+        for v in candidates:
+            if v is None:
+                continue
+            try:
+                return int(v)
+            except Exception:
+                pass
+        return None
+
+    async def handle_webhook(self, payload: Dict) -> Dict:
+        try:
+            user_id = self._extract_user_id(payload)
+            if not user_id:
+                return {"success": False, "error": "No user_id in webhook payload"}
+
+            event = (payload.get("event") or "").lower()
+            status = (payload.get("status") or "").lower()
+
+            paid = (status in ("success", "paid", "succeeded")) or ("paid" in event or "succeed" in event)
+            refunded = (status in ("refund", "refunded")) or ("refund" in event)
+
+            if paid:
+                storage.add_pro(user_id)
+                logger.info(f"User {user_id} upgraded to PRO (Prodamus webhook)")
+                return {"success": True, "message": f"User {user_id} upgraded to PRO"}
+
+            if refunded:
+                storage.remove_pro(user_id)
+                logger.info(f"User {user_id} downgraded from PRO (refund)")
+                return {"success": True, "message": f"User {user_id} downgraded from PRO"}
+
+            logger.info(f"–ü–æ–ª—É—á–µ–Ω –≤–µ–±—Ö—É–∫ Prodamus (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π —Å—Ç–∞—Ç—É—Å–∞): event={event}, status={status}")
+            return {"success": True, "message": "Webhook received"}
+
+        except Exception as e:
+            logger.error(f"Webhook error: {e}")
+            return {"success": False, "error": str(e)}
+
+    def _append_query(self, base_url: str, extra: Dict[str, str]) -> str:
+        url = urlparse(base_url)
+        q = dict(parse_qsl(url.query, keep_blank_values=True))
+        q.update({k: str(v) for k, v in extra.items()})
+        new_query = urlencode(q)
+        return urlunparse((url.scheme, url.netloc, url.path, url.params, new_query, url.fragment))
+
+    def get_payment_url(self, user_id: int, amount: Optional[float] = None) -> str:
+        amount = amount if amount is not None else self.default_amount
+        if self.payment_link_base:
+            return self._append_query(self.payment_link_base, {"user_id": user_id, "amount": amount})
+        return f"https://payform.prodamus.ru/?user_id={user_id}&amount={amount}"
diff --git a/app/web.py b/app/web.py
index 9999999..aaaaaaa 100644
--- a/app/web.py
+++ b/app/web.py
@@ -1,74 +1,91 @@
 import os
 import logging
 from flask import Flask, request, jsonify, Response
 from app.config import payment_manager
 from app.bootstrap import run_startup_migrations
 
 # Prometheus
 from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
 # –ú–µ—Ç—Ä–∏–∫–∏
 REQUESTS_TOTAL = Counter("web_requests_total", "Total web requests", ["endpoint", "method"])
 WEBHOOK_ERRORS_TOTAL = Counter("webhook_errors_total", "Webhook errors", ["reason"])
 WEBHOOK_LATENCY = Histogram("webhook_latency_seconds", "Webhook processing time")
 
 app = Flask(__name__)
 
 @app.before_request
 def _before_request():
     try:
         REQUESTS_TOTAL.labels(endpoint=request.path, method=request.method).inc()
     except Exception:
         pass
 
 @app.route("/metrics", methods=["GET"])
 def metrics():
     """–≠–∫—Å–ø–æ—Ä—Ç –º–µ—Ç—Ä–∏–∫ Prometheus."""
     data = generate_latest()
     return Response(data, mimetype=CONTENT_TYPE_LATEST)
 
-@app.route("/webhook/paydmus", methods=["POST"])
-@WEBHOOK_LATENCY.time()
-def webhook_paydmus():
-    if not payment_manager:
-        WEBHOOK_ERRORS_TOTAL.labels(reason="payments_disabled").inc()
-        return jsonify({"error": "Payments disabled"}), 503
-    try:
-        signature = request.headers.get('X-Paydmus-Signature')
-        payload = request.get_data()
-
-        if not signature:
-            WEBHOOK_ERRORS_TOTAL.labels(reason="no_signature").inc()
-            return jsonify({"error": "Missing signature"}), 401
-
-        if not payment_manager.verify_webhook_signature(payload, signature):
-            WEBHOOK_ERRORS_TOTAL.labels(reason="bad_signature").inc()
-            return jsonify({"error": "Invalid signature"}), 401
-
-        data = request.get_json(silent=True) or {}
-
-        import asyncio
-        result = asyncio.run(payment_manager.handle_webhook(data))
-        if result.get("success"):
-            return jsonify(result), 200
-        else:
-            WEBHOOK_ERRORS_TOTAL.labels(reason="handler_error").inc()
-            return jsonify(result), 400
-    except Exception as e:
-        logger.exception("Webhook error")
-        WEBHOOK_ERRORS_TOTAL.labels(reason="exception").inc()
-        return jsonify({"error": "Internal error"}), 500
+@app.route("/webhook/prodamus", methods=["POST"])
+@WEBHOOK_LATENCY.time()
+def webhook_prodamus():
+    if not payment_manager:
+        WEBHOOK_ERRORS_TOTAL.labels(reason="payments_disabled").inc()
+        return jsonify({"error": "Payments disabled"}), 503
+    try:
+        raw = request.get_data()  # raw body (bytes)
+        headers = dict(request.headers)
+
+        if not payment_manager.verify_webhook_signature(raw, headers):
+            WEBHOOK_ERRORS_TOTAL.labels(reason="bad_signature").inc()
+            return jsonify({"error": "Invalid signature"}), 401
+
+        data = request.get_json(silent=True) or {}
+        import asyncio
+        result = asyncio.run(payment_manager.handle_webhook(data))
+        if result.get("success"):
+            return jsonify(result), 200
+        else:
+            WEBHOOK_ERRORS_TOTAL.labels(reason="handler_error").inc()
+            return jsonify(result), 400
+    except Exception as e:
+        logger.exception("Webhook error")
+        WEBHOOK_ERRORS_TOTAL.labels(reason="exception").inc()
+        return jsonify({"error": "Internal error"}), 500
 
 @app.route("/health", methods=["GET"])
 def health():
     return jsonify({"ok": True})
 
 if __name__ == "__main__":
     # –ú–∏–≥—Ä–∞—Ü–∏—è PRO –∏–∑ ENV ‚Üí Redis/Postgres (–∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ)
     run_startup_migrations()
 
     port = int(os.environ.get("PORT", "8000"))
     app.run(host="0.0.0.0", port=port)
diff --git a/README.md b/README.md
index bbbbbbb..ccccccc 100644
--- a/README.md
+++ b/README.md
@@ -1,54 +1,76 @@
 # AI-Vera Transcribator ü§ñ
 
 Telegram-–±–æ—Ç –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ –∞—É–¥–∏–æ –∏ –≤–∏–¥–µ–æ –≤ —Ç–µ–∫—Å—Ç —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π AI.
 
 ## –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏
 
 - üé§ –¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—è –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
 - üìÅ –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞—É–¥–∏–æ –∏ –≤–∏–¥–µ–æ —Ñ–∞–π–ª–æ–≤ (–¥–æ 20 –ú–ë)
 - üåê –ü–æ–¥–¥–µ—Ä–∂–∫–∞ YouTube, –Ø–Ω–¥–µ–∫—Å.–î–∏—Å–∫, Google Drive
 - üíé PRO-—Å—Ç–∞—Ç—É—Å —Å —É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–º–∏ –ª–∏–º–∏—Ç–∞–º–∏
 - üìÑ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è PDF —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
 - ‚ö° –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å –æ—á–µ—Ä–µ–¥—è–º–∏
 
 ## –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞ Render.com
 
 1. **–§–æ—Ä–∫–Ω–∏—Ç–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π** –∏ –ø–æ–¥–∫–ª—é—á–∏—Ç–µ –∫ Render.com
 2. **–î–æ–±–∞–≤—å—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è** –≤ –ø–∞–Ω–µ–ª–∏ Render:
-   - `TELEGRAM_BOT_TOKEN` - —Ç–æ–∫–µ–Ω –æ—Ç @BotFather
-   - `ADMIN_USER_IDS` - ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é
-   - `PAYDUS_WEBHOOK_SECRET` - —Å–µ–∫—Ä–µ—Ç –∏–∑ –∫–∞–±–∏–Ω–µ—Ç–∞ Paydmus
-3. **–ù–∞—Å—Ç—Ä–æ–π—Ç–µ webhook** –≤ Paydmus –Ω–∞: `https://your-app-name.onrender.com/webhook/paydmus`
+   - `TELEGRAM_BOT_TOKEN` ‚Äî —Ç–æ–∫–µ–Ω –æ—Ç @BotFather
+   - `ADMIN_USER_IDS` ‚Äî ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é
+   - `PRODAMUS_WEBHOOK_SECRET` ‚Äî —Å–µ–∫—Ä–µ—Ç –∏–∑ –∫–∞–±–∏–Ω–µ—Ç–∞ **Prodamus**
+   - `PRODAMUS_PAYMENT_LINK` ‚Äî –ø–ª–∞—Ç—ë–∂–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ **Prodamus**
+3. **–ù–∞—Å—Ç—Ä–æ–π—Ç–µ webhook** –≤ **Prodamus** –Ω–∞:  
+   `https://your-app-name.onrender.com/webhook/prodamus`
 4. **–î–µ–ø–ª–æ–π** - Render –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–±–µ—Ä–µ—Ç –∏ –∑–∞–ø—É—Å—Ç–∏—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
 
 ## –õ–æ–∫–∞–ª—å–Ω–∞—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞
 
 1. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:
 ```bash
 pip install -r requirements.txt
+```
+
+2. –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –ª–æ–∫–∞–ª—å–Ω–æ:
+```bash
+python -m app.bot
+```
+
+3. –ó–∞–ø—É—Å–∫ –≤–µ–±-—Å–µ—Ä–≤–∏—Å–∞ –ª–æ–∫–∞–ª—å–Ω–æ (–º–µ—Ç—Ä–∏–∫–∏/–≤–µ–±—Ö—É–∫):
+```bash
+python -m app.web
