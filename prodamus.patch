diff --git a/.env.example b/.env.example
index 1111111..2222222 100644
--- a/.env.example
+++ b/.env.example
@@ -1,13 +1,22 @@
-# Обязательные переменные
-TELEGRAM_BOT_TOKEN=your_telegram_bot_token_here
-ADMIN_USER_IDS=123456789
-
-# Paydmus настройки
-PAYDUS_WEBHOOK_SECRET=your_paydmus_webhook_secret
-PAYDUS_PRO_AMOUNT=299.0
-
-# Опциональные переменные
-PRO_USER_IDS=987654321
-WHISPER_MODEL=base
+# Обязательные переменные
+TELEGRAM_BOT_TOKEN=your_telegram_bot_token_here
+ADMIN_USER_IDS=123456789
+
+# Prodamus
+PRODAMUS_WEBHOOK_SECRET=your_prodamus_webhook_secret
+# Готовая платёжная ссылка из кабинета Prodamus (страница оплаты).
+# Можно оставить без параметров — бот добавит ?user_id=...&amount=...
+PRODAMUS_PAYMENT_LINK=https://payform.prodamus.ru/your-page
+PRODAMUS_PRO_AMOUNT=299.0
+
+# Распознавание
+WHISPER_BACKEND=faster   # "openai" или "faster"
+WHISPER_MODEL=small      # openai: base/small/...; faster: small/medium/large-v3 и т.п.
+
+# Опциональные переменные
+PRO_USER_IDS=987654321
+
+# Хранилища (опционально)
+# REDIS_URL=redis://default:password@host:6379/0
+# DATABASE_URL=postgresql://user:password@host:5432/dbname
diff --git a/render.yaml b/render.yaml
index 3333333..4444444 100644
--- a/render.yaml
+++ b/render.yaml
@@ -1,44 +1,56 @@
 services:
   - type: worker
     name: ai-vera-bot-worker
     runtime: docker
     dockerfilePath: Dockerfile
-    dockerCommand: python -m app.bot
+    dockerCommand: python -m app.bot
     envVars:
-      - key: PRO_USER_IDS
-        sync: false
       - key: TELEGRAM_BOT_TOKEN
         sync: false
       - key: ADMIN_USER_IDS
         sync: false
-      - key: PRO_USER_IDS
-        sync: false
-      - key: PAYDUS_WEBHOOK_SECRET
+      - key: PRO_USER_IDS
         sync: false
-      - key: PAYDUS_PRO_AMOUNT
-        value: "299.0"
-        - key: WHISPER_BACKEND       # "openai" или "faster"
-        value: "faster"
-      - key: WHISPER_MODEL         # для openai: base/small/...; для faster: small/medium/large-v3 и т.п.
-        value: "small"
+      - key: PRODAMUS_WEBHOOK_SECRET
+        sync: false
+      - key: PRODAMUS_PAYMENT_LINK
+        sync: false
+      - key: PRODAMUS_PRO_AMOUNT
+        value: "299.0"
+      - key: WHISPER_BACKEND         # "openai" или "faster"
+        value: "faster"
+      - key: WHISPER_MODEL           # openai: base/small/...; faster: small/medium/large-v3
+        value: "small"
       - key: REDIS_URL             # опционально
         sync: false
       - key: DATABASE_URL          # опционально (postgres://... или postgresql://...)
         sync: false
 
   - type: web
     name: ai-vera-bot-web
     runtime: docker
     dockerfilePath: Dockerfile
-    dockerCommand: python -m app.web
+    dockerCommand: gunicorn -w 2 -k gthread -b 0.0.0.0:$PORT app.web:app
     envVars:
       - key: TELEGRAM_BOT_TOKEN
         sync: false
       - key: ADMIN_USER_IDS
         sync: false
       - key: PRO_USER_IDS
         sync: false
-      - key: PAYDUS_WEBHOOK_SECRET
+      - key: PRODAMUS_WEBHOOK_SECRET
         sync: false
-      - key: PAYDUS_PRO_AMOUNT
-        value: "299.0"
+      - key: PRODAMUS_PAYMENT_LINK
+        sync: false
+      - key: PRODAMUS_PRO_AMOUNT
+        value: "299.0"
+      - key: WHISPER_BACKEND
+        value: "faster"
+      - key: WHISPER_MODEL
+        value: "small"
+      - key: REDIS_URL
+        sync: false
+      - key: DATABASE_URL
+        sync: false
diff --git a/app/config.py b/app/config.py
index 5555555..6666666 100644
--- a/app/config.py
+++ b/app/config.py
@@ -1,33 +1,43 @@
 import os
 from dotenv import load_dotenv
 from app.payment_manager import PaymentManager
 
 load_dotenv()
 
 TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
 if not TELEGRAM_BOT_TOKEN:
     raise ValueError("ОШИБКА: Не найден TELEGRAM_BOT_TOKEN в переменных окружения.")
 
 FREE_USER_DAILY_LIMIT_MINUTES = 30
 PRO_USER_DAILY_LIMIT_MINUTES = 120
 MAX_FILE_SIZE_MB = 20
 
 ADMIN_USER_IDS = list(map(int, os.getenv('ADMIN_USER_IDS', '').split(','))) if os.getenv('ADMIN_USER_IDS') else []
 PRO_USER_IDS = list(map(int, os.getenv('PRO_USER_IDS', '').split(','))) if os.getenv('PRO_USER_IDS') else []
 
 # Бэкенд распознавания: "openai" | "faster"
 WHISPER_BACKEND = os.getenv('WHISPER_BACKEND', 'faster').lower()
 WHISPER_MODEL = os.getenv('WHISPER_MODEL', 'small')
 
-# Paydmus
-PAYDMUS_WEBHOOK_SECRET = os.getenv('PAYDMUS_WEBHOOK_SECRET', '')
-PAYDMUS_PRO_AMOUNT = float(os.getenv('PAYDMUS_PRO_AMOUNT', '299.0'))
+# Prodamus
+PRODAMUS_WEBHOOK_SECRET = os.getenv('PRODAMUS_WEBHOOK_SECRET', '')
+PRODAMUS_PRO_AMOUNT = float(os.getenv('PRODAMUS_PRO_AMOUNT', '299.0'))
+PRODAMUS_PAYMENT_LINK = os.getenv('PRODAMUS_PAYMENT_LINK', '').strip()
 
 # Хранилища
 REDIS_URL = os.getenv('REDIS_URL', '')
 DATABASE_URL = os.getenv('DATABASE_URL', '')
 
 payment_manager = None
-if PAYDMUS_WEBHOOK_SECRET:
-    payment_manager = PaymentManager(PAYDMUS_WEBHOOK_SECRET)
+if PRODAMUS_WEBHOOK_SECRET:
+    payment_manager = PaymentManager(
+        webhook_secret=PRODAMUS_WEBHOOK_SECRET,
+        payment_link_base=PRODAMUS_PAYMENT_LINK or None,
+        default_amount=PRODAMUS_PRO_AMOUNT
+    )
 else:
-    print("⚠️  PAYDMUS_WEBHOOK_SECRET не установлен. Платежи отключены.")
+    print("⚠️  PRODAMUS_WEBHOOK_SECRET не установлен. Платежи отключены.")
diff --git a/app/payment_manager.py b/app/payment_manager.py
index 7777777..8888888 100644
--- a/app/payment_manager.py
+++ b/app/payment_manager.py
@@ -1,53 +1,168 @@
-import logging
-import hmac
-import hashlib
-from typing import Dict
-from app import storage
-
-logger = logging.getLogger(__name__)
-
-class PaymentManager:
-    """Paydmus."""
-    def __init__(self, webhook_secret: str):
-        self.webhook_secret = webhook_secret.encode('utf-8')
-
-    def verify_webhook_signature(self, payload: bytes, signature: str) -> bool:
-        try:
-            expected = hmac.new(self.webhook_secret, payload, hashlib.sha256).hexdigest()
-            return hmac.compare_digest(expected, signature)
-        except Exception as e:
-            logger.error(f"Ошибка проверки подписи: {e}")
-            return False
-
-    async def handle_webhook(self, payload: Dict) -> Dict:
-        try:
-            event = payload.get('event')
-            order = payload.get('order', {})
-            user_id = order.get('user_id')
-            if not user_id:
-                return {'success': False, 'error': 'No user_id'}
-
-            user_id = int(user_id)
-
-            if event == 'order.paid':
-                storage.add_pro(user_id)
-                logger.info(f"User {user_id} upgraded to PRO")
-                return {'success': True, 'message': f'User {user_id} upgraded to PRO'}
-
-            elif event == 'order.refunded':
-                storage.remove_pro(user_id)
-                logger.info(f"User {user_id} downgraded from PRO")
-                return {'success': True, 'message': f'User {user_id} downgraded from PRO'}
-
-            return {'success': False, 'error': 'Unknown event type'}
-        except Exception as e:
-            logger.error(f"Webhook error: {e}")
-            return {'success': False, 'error': str(e)}
-
-    def get_payment_url(self, user_id: int, amount: float = 299.0) -> str:
-        base_url = "https://paydmus.com/api/v1/payment"
-        return f"{base_url}?user_id={user_id}&amount={amount}&product_name=AI+Vera+PRO"
+import logging
+import hmac
+import hashlib
+import json
+from typing import Dict, Optional
+from urllib.parse import urlencode, urlparse, parse_qsl, urlunparse
+
+from app import storage
+
+logger = logging.getLogger(__name__)
+
+class PaymentManager:
+    """
+    Интеграция с Prodamus:
+    - Проверка подписи вебхука: HMAC-SHA256(raw_body, secret) == signature_header
+    - Ссылка на оплату: используем готовую ссылку из кабинета и добавляем ?user_id=...&amount=...
+    """
+
+    SIGNATURE_HEADER_CANDIDATES = [
+        "X-Prodamus-Signature",
+        "X-Signature",
+        "Signature",
+        "X-Pay-Signature",
+    ]
+
+    def __init__(self, webhook_secret: str, payment_link_base: Optional[str], default_amount: float = 299.0):
+        self.webhook_secret = webhook_secret.encode("utf-8")
+        self.payment_link_base = payment_link_base
+        self.default_amount = default_amount
+
+    def _extract_signature(self, headers: Dict[str, str]) -> Optional[str]:
+        for key in self.SIGNATURE_HEADER_CANDIDATES:
+            if key in headers:
+                return headers.get(key)
+            for hk, hv in headers.items():
+                if hk.lower() == key.lower():
+                    return hv
+        return None
+
+    def verify_webhook_signature(self, raw_payload: bytes, headers: Dict[str, str]) -> bool:
+        try:
+            signature = self._extract_signature(headers)
+            if not signature:
+                logger.warning("Подпись вебхука отсутствует в заголовках")
+                return False
+            expected = hmac.new(self.webhook_secret, raw_payload, hashlib.sha256).hexdigest()
+            return hmac.compare_digest(expected, signature)
+        except Exception as e:
+            logger.error(f"Ошибка проверки подписи: {e}")
+            return False
+
+    def _extract_user_id(self, payload: Dict) -> Optional[int]:
+        candidates = [
+            payload.get("user_id"),
+            (payload.get("order") or {}).get("user_id"),
+            ((payload.get("custom_fields") or {}).get("user_id") if isinstance(payload.get("custom_fields"), dict) else None),
+            ((payload.get("params") or {}).get("user_id") if isinstance(payload.get("params"), dict) else None),
+            ((payload.get("client") or {}).get("user_id") if isinstance(payload.get("client"), dict) else None),
+        ]
+        for v in candidates:
+            if v is None:
+                continue
+            try:
+                return int(v)
+            except Exception:
+                pass
+        return None
+
+    async def handle_webhook(self, payload: Dict) -> Dict:
+        try:
+            user_id = self._extract_user_id(payload)
+            if not user_id:
+                return {"success": False, "error": "No user_id in webhook payload"}
+
+            event = (payload.get("event") or "").lower()
+            status = (payload.get("status") or "").lower()
+
+            paid = (status in ("success", "paid", "succeeded")) or ("paid" in event or "succeed" in event)
+            refunded = (status in ("refund", "refunded")) or ("refund" in event)
+
+            if paid:
+                storage.add_pro(user_id)
+                logger.info(f"User {user_id} upgraded to PRO (Prodamus webhook)")
+                return {"success": True, "message": f"User {user_id} upgraded to PRO"}
+
+            if refunded:
+                storage.remove_pro(user_id)
+                logger.info(f"User {user_id} downgraded from PRO (refund)")
+                return {"success": True, "message": f"User {user_id} downgraded from PRO"}
+
+            logger.info(f"Получен вебхук Prodamus (без изменений статуса): event={event}, status={status}")
+            return {"success": True, "message": "Webhook received"}
+
+        except Exception as e:
+            logger.error(f"Webhook error: {e}")
+            return {"success": False, "error": str(e)}
+
+    def _append_query(self, base_url: str, extra: Dict[str, str]) -> str:
+        url = urlparse(base_url)
+        q = dict(parse_qsl(url.query, keep_blank_values=True))
+        q.update({k: str(v) for k, v in extra.items()})
+        new_query = urlencode(q)
+        return urlunparse((url.scheme, url.netloc, url.path, url.params, new_query, url.fragment))
+
+    def get_payment_url(self, user_id: int, amount: Optional[float] = None) -> str:
+        amount = amount if amount is not None else self.default_amount
+        if self.payment_link_base:
+            return self._append_query(self.payment_link_base, {"user_id": user_id, "amount": amount})
+        return f"https://payform.prodamus.ru/?user_id={user_id}&amount={amount}"
diff --git a/app/web.py b/app/web.py
index 9999999..aaaaaaa 100644
--- a/app/web.py
+++ b/app/web.py
@@ -1,74 +1,91 @@
 import os
 import logging
 from flask import Flask, request, jsonify, Response
 from app.config import payment_manager
 from app.bootstrap import run_startup_migrations
 
 # Prometheus
 from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
 # Метрики
 REQUESTS_TOTAL = Counter("web_requests_total", "Total web requests", ["endpoint", "method"])
 WEBHOOK_ERRORS_TOTAL = Counter("webhook_errors_total", "Webhook errors", ["reason"])
 WEBHOOK_LATENCY = Histogram("webhook_latency_seconds", "Webhook processing time")
 
 app = Flask(__name__)
 
 @app.before_request
 def _before_request():
     try:
         REQUESTS_TOTAL.labels(endpoint=request.path, method=request.method).inc()
     except Exception:
         pass
 
 @app.route("/metrics", methods=["GET"])
 def metrics():
     """Экспорт метрик Prometheus."""
     data = generate_latest()
     return Response(data, mimetype=CONTENT_TYPE_LATEST)
 
-@app.route("/webhook/paydmus", methods=["POST"])
-@WEBHOOK_LATENCY.time()
-def webhook_paydmus():
-    if not payment_manager:
-        WEBHOOK_ERRORS_TOTAL.labels(reason="payments_disabled").inc()
-        return jsonify({"error": "Payments disabled"}), 503
-    try:
-        signature = request.headers.get('X-Paydmus-Signature')
-        payload = request.get_data()
-
-        if not signature:
-            WEBHOOK_ERRORS_TOTAL.labels(reason="no_signature").inc()
-            return jsonify({"error": "Missing signature"}), 401
-
-        if not payment_manager.verify_webhook_signature(payload, signature):
-            WEBHOOK_ERRORS_TOTAL.labels(reason="bad_signature").inc()
-            return jsonify({"error": "Invalid signature"}), 401
-
-        data = request.get_json(silent=True) or {}
-
-        import asyncio
-        result = asyncio.run(payment_manager.handle_webhook(data))
-        if result.get("success"):
-            return jsonify(result), 200
-        else:
-            WEBHOOK_ERRORS_TOTAL.labels(reason="handler_error").inc()
-            return jsonify(result), 400
-    except Exception as e:
-        logger.exception("Webhook error")
-        WEBHOOK_ERRORS_TOTAL.labels(reason="exception").inc()
-        return jsonify({"error": "Internal error"}), 500
+@app.route("/webhook/prodamus", methods=["POST"])
+@WEBHOOK_LATENCY.time()
+def webhook_prodamus():
+    if not payment_manager:
+        WEBHOOK_ERRORS_TOTAL.labels(reason="payments_disabled").inc()
+        return jsonify({"error": "Payments disabled"}), 503
+    try:
+        raw = request.get_data()  # raw body (bytes)
+        headers = dict(request.headers)
+
+        if not payment_manager.verify_webhook_signature(raw, headers):
+            WEBHOOK_ERRORS_TOTAL.labels(reason="bad_signature").inc()
+            return jsonify({"error": "Invalid signature"}), 401
+
+        data = request.get_json(silent=True) or {}
+        import asyncio
+        result = asyncio.run(payment_manager.handle_webhook(data))
+        if result.get("success"):
+            return jsonify(result), 200
+        else:
+            WEBHOOK_ERRORS_TOTAL.labels(reason="handler_error").inc()
+            return jsonify(result), 400
+    except Exception as e:
+        logger.exception("Webhook error")
+        WEBHOOK_ERRORS_TOTAL.labels(reason="exception").inc()
+        return jsonify({"error": "Internal error"}), 500
 
 @app.route("/health", methods=["GET"])
 def health():
     return jsonify({"ok": True})
 
 if __name__ == "__main__":
     # Миграция PRO из ENV → Redis/Postgres (идемпотентно)
     run_startup_migrations()
 
     port = int(os.environ.get("PORT", "8000"))
     app.run(host="0.0.0.0", port=port)
diff --git a/README.md b/README.md
index bbbbbbb..ccccccc 100644
--- a/README.md
+++ b/README.md
@@ -1,54 +1,76 @@
 # AI-Vera Transcribator 🤖
 
 Telegram-бот для транскрибации аудио и видео в текст с поддержкой AI.
 
 ## Возможности
 
 - 🎤 Транскрибация голосовых сообщений
 - 📁 Обработка аудио и видео файлов (до 20 МБ)
 - 🌐 Поддержка YouTube, Яндекс.Диск, Google Drive
 - 💎 PRO-статус с увеличенными лимитами
 - 📄 Генерация PDF с результатами
 - ⚡ Асинхронная обработка с очередями
 
 ## Установка на Render.com
 
 1. **Форкните репозиторий** и подключите к Render.com
 2. **Добавьте переменные окружения** в панели Render:
-   - `TELEGRAM_BOT_TOKEN` - токен от @BotFather
-   - `ADMIN_USER_IDS` - ID администраторов через запятую
-   - `PAYDUS_WEBHOOK_SECRET` - секрет из кабинета Paydmus
-3. **Настройте webhook** в Paydmus на: `https://your-app-name.onrender.com/webhook/paydmus`
+   - `TELEGRAM_BOT_TOKEN` — токен от @BotFather
+   - `ADMIN_USER_IDS` — ID администраторов через запятую
+   - `PRODAMUS_WEBHOOK_SECRET` — секрет из кабинета **Prodamus**
+   - `PRODAMUS_PAYMENT_LINK` — платёжная страница **Prodamus**
+3. **Настройте webhook** в **Prodamus** на:  
+   `https://your-app-name.onrender.com/webhook/prodamus`
 4. **Деплой** - Render автоматически соберет и запустит приложение
 
 ## Локальная разработка
 
 1. Установите зависимости:
 ```bash
 pip install -r requirements.txt
+```
+
+2. Запуск бота локально:
+```bash
+python -m app.bot
+```
+
+3. Запуск веб-сервиса локально (метрики/вебхук):
+```bash
+python -m app.web
